# -*- coding: utf-8 -*-
"""Задание 13.12.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CUZ3x6uLQG2VDWtvydZMFawNEPYsuQdp
"""

import numpy as np # linear algebra
import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)

# Input data files are available in the read-only "../input/" directory
# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory

from random import randint
from matplotlib import pyplot as plt
from math import exp,log

x1 = [0.58, 1.72, 0.33, 1.34, 1.76, 1.54, 1.83, 0.84, 1.11, 1.06]
y1 = [1.81, 0.44, 0.62, 0.74, 1.64, 0.92, 1.55, 0.27, 0.7, 0.24]
x2 = [2.78, 5.14, 6.17, 3.11, 2.23, 1.78, 1.88]
y2 = [4.87, 4.54, 1.12, 0.59, 0.43, 4.61, 0.25]

plt.scatter(x=x1, y=y1, color='red')
plt.scatter(x=x2, y=y2, color='green')
plt.show()

#Сначала нужно сделать предобработку данных, сделать набор входных и выходных данных, делаем списки точек (векторов признаков).
inputs = [(x1[i], y1[i]) for i in range(len(x1))]
targets = [0 for i in range(len(x1))]
inputs += [(x2[i], y2[i]) for i in range(len(x2))]
targets += [1 for i in range(len(x2))]

#Создаем веса и функции, которые будут обрабатывать ответ модели.
weights = [randint(-100, 100) / 100 for _ in range(3)]

def weighted_z(point):
    z = [item * weights[i] for i, item in enumerate(point)]
    return sum(z) + weights[-1]

def logistic_function(z):
    return 1/(1 + exp(-z))

#Далее создаем функцию для расчета логистической функции ошибки для всего набора данных,
#используется формула логистической функции ошибки для каждой пары ответа и целевого значения.
def logistic_error():
    errors = []

    for i, point in enumerate(inputs):
        z = weighted_z(point)
        output = logistic_function(z)
        target = targets[i]

        if output == 1:
            output = 0.99999

        if output == 0:
            output = 0.00001

        error = -(target * log(output) - (1 - target) * log(1 - output))
        errors.append(error)

    return sum(errors) / len(errors)

#Далее делаем процедуру обучения весов на всем наборе данных.
lr = 0.2

for epoch in range(400):
    for i, point in enumerate(inputs):
        z = weighted_z(point)
        output = logistic_function(z)
        target = targets[i]

        for j in range(len(weights) - 1):
            weights[j] -= lr * point[j] * (output - target) * (1 / len(inputs))

        weights[-1] -= lr * (output - target) * (1 / len(inputs))

    print(f"epoch: {epoch}, error: {logistic_error()}")

print(weights)

#Ответы модели на все входные данные можно посмотреть таким образом:
def test():
    for i, point in enumerate(inputs):
        z = weighted_z(point)
        output = logistic_function(z)
        target = targets[i]
        print(f"output: {round(output, 2)}, target: {target}")
test()

#Оцениваем качество классификации полученной модели с помощью метрики accuracy.
def accuracy():
    true_outputs = 0

    for i, point in enumerate(inputs):
        z = weighted_z(point)
        output = logistic_function(z)
        target = targets[i]

        if round(output) == target:
            true_outputs += 1

    return true_outputs, len(inputs)

print("accuracy:", accuracy())